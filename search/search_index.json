{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DAA for Kids","text":"<p>Welcome to the DAA for Kids project \u2013 a unique and engaging platform dedicated to demystifying the complexities of Design and Analysis of Algorithms (DAA) through interactive visualization. We believe that understanding algorithms should be an intuitive and exciting journey, and this project provides the tools to make that a reality.</p>"},{"location":"#project-vision","title":"Project Vision","text":"<p>The DAA for Kids project transforms the traditional study of algorithms into a dynamic, visual experience. Our core mission is to provide students, educators, and enthusiasts with an accessible environment to see how algorithms work in real-time. By visualizing the step-by-step execution of various algorithms, from fundamental sorting to complex pathfinding and optimization problems, we aim to bridge the gap between abstract theory and practical understanding.</p> <p>Through this platform, users can not only observe but actively interact with algorithms, gaining deeper insights into their logic, efficiency, and behavior under different conditions.</p>"},{"location":"#explore-the-core-modules","title":"Explore the Core Modules","text":"<p>The project is structured into several key modules, each offering a focused, interactive visualization experience for specific categories of algorithms. Each module is designed to provide clarity and foster a deeper understanding through hands-on engagement.</p>"},{"location":"#1-pathfinding-algorithm-visualizer","title":"1. Pathfinding Algorithm Visualizer","text":"<p>Embark on a visual journey through the world of graph traversal. Our interactive grid editor allows you to set up scenarios and watch as popular pathfinding algorithms find their way. Configure start/end nodes, add walls and weights, and control the visualization speed to observe how different algorithms explore the space and determine the optimal path.</p> <p>Algorithms Visualized: This visualizer supports a wide range of algorithms, including Breadth-First Search (BFS), Depth-First Search (DFS) for unweighted graphs, Dijkstra\u2019s Algorithm, A* Search, Greedy Best-First Search, Bellman-Ford, and Floyd-Warshall for weighted graphs, as well as advanced techniques like Bidirectional Search, Jump Point Search, and Segment Search.</p> <p>Understanding pathfinding is crucial in areas like AI, robotics, and network routing. This visualizer helps illustrate the trade-offs between algorithm complexity, optimality, and performance.</p>"},{"location":"#2-knapsack-problem-visualizer","title":"2. Knapsack Problem Visualizer","text":"<p>Tackle the classic 0/1 Knapsack Problem with an intuitive visualization of the Dynamic Programming solution. Define your knapsack capacity and a set of items with specific weights and values, then watch as the algorithm fills the knapsack to maximize the total value. The step-by-step visualization of the DP table makes the concept of optimal substructure and overlapping subproblems crystal clear.</p> <p>This module is an excellent tool for grasping the power and methodology of dynamic programming for optimization problems.</p>"},{"location":"#3-longest-common-subsequence-lcs-visualizer","title":"3. Longest Common Subsequence (LCS) Visualizer","text":"<p>Delve into string algorithms with the Longest Common Subsequence (LCS) visualizer. This tool demonstrates how the LCS algorithm, a cornerstone of dynamic programming and bioinformatics, finds the longest sequence of characters common to two strings. Interact with different string inputs and observe the construction of the DP table to understand how the LCS is derived.</p> <p>Visualizing LCS helps illustrate fundamental concepts in sequence alignment and comparison.</p>"},{"location":"#4-huffman-encoding-visualizer","title":"4. Huffman Encoding Visualizer","text":"<p>Explore the principles of data compression with the Huffman Encoding visualizer. See how this widely used algorithm constructs a prefix code based on character frequencies to achieve efficient compression. The visualization walks you through building the Huffman tree and assigning variable-length codes. Compare its effectiveness with other methods to appreciate the benefits of optimal encoding.</p> <p>This module provides a practical look at how algorithms are applied to real-world problems like file compression.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to dive in? To start exploring the fascinating world of algorithms through visualization, you can either access a hosted version of the project (if available) or set it up locally.</p> <p>Setting up the project locally provides the best experience for deep exploration and even contributing to the project. Please refer to the Installation Guide for detailed instructions on how to get the project up and running on your machine.</p> <p>Once installed, you can navigate through the different modules to interact with the visualizations and enhance your understanding of each algorithm.</p>"},{"location":"#join-our-community","title":"Join Our Community","text":"<p>We hope the DAA for Kids platform makes learning algorithms an enjoyable and insightful process for students of all levels. Whether you are here to learn, teach, or contribute, your engagement is valued.</p> <p>Start exploring, experimenting, and visualizing the power of algorithms today!</p>"},{"location":"contributing/","title":"Contributing to DAA for Kids","text":"<p>The DAA for Kids project thrives on community involvement. Contributions from individuals like you are essential for improving the visualizers, adding new algorithms, enhancing documentation, and making the study of algorithms more accessible for everyone. Whether you are a seasoned developer, a student learning to code, or someone passionate about education, your contributions are highly valued.</p>"},{"location":"contributing/#why-contribute","title":"Why Contribute?","text":"<p>Contributing to an open-source project like DAA for Kids offers numerous benefits:</p> <ul> <li>Skill Development: Gain practical experience in software development, collaboration, and working with a codebase.</li> <li>Learning Opportunity: Deepen your understanding of algorithms and the technologies used in the project (e.g., JavaScript, React, web development).</li> <li>Community Engagement: Become part of a community of learners and developers who share a common interest.</li> <li>Making an Impact: Help improve an educational tool that can benefit students and educators worldwide.</li> <li>Building Your Portfolio: Showcase your contributions to potential employers or collaborators.</li> </ul>"},{"location":"contributing/#how-to-file-issues","title":"How to File Issues","text":"<p>Identifying and reporting bugs or suggesting new features is a crucial form of contribution. Well-documented issues help maintainers understand the problem and facilitate solutions.</p> <p>If you encounter a bug, have a feature request, or notice something that could be improved, please file an issue on the project's GitHub repository. Follow these guidelines to make your issue effective:</p> <ol> <li>Check Existing Issues: Before creating a new issue, search the repository's existing issues to see if the problem or suggestion has already been reported.</li> <li>Provide a Clear Title: Summarize the issue concisely in the title.</li> <li>Describe the Problem/Suggestion:<ul> <li>For Bugs: Explain the problem in detail. Include steps to reproduce the bug, expected behavior, actual behavior, and information about your environment (e.g., browser, operating system, project version if applicable). Include screenshots or recordings if possible.</li> <li>For Feature Requests: Clearly describe the desired feature, its potential benefits, and how it would enhance the project.</li> </ul> </li> <li>Add Labels: If you have permissions, add relevant labels (e.g., <code>bug</code>, <code>feature request</code>, <code>documentation</code>) to help categorize the issue.</li> </ol> <p>Filing clear and detailed issues makes it much easier for contributors to understand and address them.</p>"},{"location":"contributing/#navigating-the-project-directory","title":"Navigating the Project Directory","text":"<p>To contribute code, you'll need to understand how the project's files are organized. Familiarizing yourself with the directory structure will help you locate relevant code, make changes, and add new features.</p> <p>Based on the project overview you shared, here's a look at some key directories and files you'll likely encounter in the root of the repository:</p> <pre><code>/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 next.config.js\n\u251c\u2500\u2500 postcss.config.js\n\u251c\u2500\u2500 tailwind.config.js\n\u251c\u2500\u2500 tsconfig.json\n\u2514\u2500\u2500 ... other configuration files\n</code></pre> <ul> <li><code>public/</code>: This directory typically contains static assets that are served directly, such as images, fonts, or the <code>favicon.ico</code>.</li> <li><code>src/</code>: This is usually where the main application source code resides. Within <code>src/</code>, you would expect to find subdirectories for different parts of the application, such as components, pages, utilities, and potentially the core logic for each algorithm visualizer. This is where you'll spend most of your time if you're adding new features or fixing bugs in the visualizers.</li> <li><code>.gitignore</code>: Specifies intentionally untracked files that Git should ignore (e.g., build artifacts, dependency folders like <code>node_modules</code>, temporary files).</li> <li><code>README.md</code>: The main documentation file that provides an overview of the project, installation instructions, and basic usage information.</li> <li><code>package.json</code>: This file is crucial for Node.js projects. It lists the project's dependencies, scripts for running tasks (like <code>npm run dev</code>, <code>npm run build</code>), and other project metadata.</li> <li><code>package-lock.json</code>: Automatically generated file that records the exact versions of dependencies used, ensuring consistent installations across different environments.</li> <li><code>next.config.js</code>: Configuration file for Next.js, a React framework often used for building web applications.</li> <li><code>postcss.config.js</code>, <code>tailwind.config.js</code>: Configuration files related to styling, likely indicating the use of PostCSS and Tailwind CSS for managing styles.</li> <li><code>tsconfig.json</code>: Configuration file for TypeScript, suggesting the project is written in TypeScript, which adds static typing.</li> </ul> <p>Understanding this structure helps you navigate the codebase. If you want to work on the Pathfinding visualizer, you'd look within <code>src/</code> for a directory or file related to pathfinding. If you're updating dependencies, you'd modify <code>package.json</code>.</p>"},{"location":"contributing/#getting-started-with-code-contributions","title":"Getting Started with Code Contributions","text":"<ol> <li>Fork the Repository: Create your own copy of the project repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.</li> <li>Set up the Project: Follow the Installation Guide to get the project running locally.</li> <li>Choose an Issue: Look for open issues on the GitHub repository, especially those tagged as <code>good first issue</code> if you're new to contributing.</li> <li>Create a Branch: Create a new branch for your work (<code>git checkout -b feature/your-feature-name</code> or <code>git checkout -b bugfix/issue-#</code>).</li> <li>Make Changes: Write code, update documentation, or fix bugs. Refer to the directory structure to find the relevant files.</li> <li>Test Your Changes: Ensure your changes work correctly and don't introduce new issues.</li> <li>Commit Your Changes: Write clear and concise commit messages.</li> <li>Push to Your Fork: Push your branch to your repository on GitHub.</li> <li>Open a Pull Request: Open a Pull Request from your branch on your fork to the main project repository. Describe your changes and reference the issue you are addressing.</li> </ol> <p>Maintainers will review your Pull Request, provide feedback, and work with you to get your contribution merged.</p> <p>We are excited to welcome new contributors! Your unique skills and perspectives can help make DAA for Kids an even better resource for learning algorithms. Don't hesitate to ask questions on the issue tracker or discussions forum if you need help getting started.</p>"},{"location":"installation/","title":"Installation","text":"<p>To get started with the project, follow these steps to set it up on your local machine. Hosting the project locally provides a powerful environment for experimenting with the code, understanding its structure, and potentially contributing to its development.</p> <p>Before you begin, ensure you have the following prerequisites installed:</p> <ul> <li>Git: For cloning the repository. You can download it from https://git-scm.com/.</li> <li>Node.js and npm: Node.js is a JavaScript runtime, and npm is its package manager. They are essential for running the project. Download the latest version from https://nodejs.org/.</li> </ul> <p>Once you have the prerequisites in place, proceed with the installation steps:</p>"},{"location":"installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>The first step is to obtain a copy of the project's source code. This is done by cloning the repository from GitHub.</p> <p>Open your terminal or command prompt and execute the following commands:</p> <pre><code>git clone https://github.com/muhamad-bilal/daa-for-kids.git\ncd daa-for-kids\n</code></pre> <ul> <li><code>git clone [repository_url]</code>: This command downloads the entire project source code from the specified GitHub URL to your local machine, creating a new directory named <code>daa-for-kids</code>.</li> <li><code>cd daa-for-kids</code>: This command changes your current directory in the terminal to the newly created project directory. You must be in this directory to run subsequent commands.</li> </ul> <p>Cloning the repository gives you a complete snapshot of the project code, allowing you to browse files, understand the directory structure, and see how different components interact.</p>"},{"location":"installation/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>This project relies on various external libraries and packages to function correctly. These are listed in the <code>package.json</code> file. The next step is to install these dependencies.</p> <p>While in the project's root directory (<code>daa-for-kids</code>), run the following command:</p> <pre><code>npm install\n</code></pre> <ul> <li><code>npm install</code>: This command reads the <code>package.json</code> file and downloads all the necessary packages listed there into a <code>node_modules</code> folder within your project directory. This makes all required libraries available for the project to use.</li> </ul> <p>Installing dependencies locally ensures that you have all the necessary building blocks to run the application and explore its code without external network dependencies (after the initial installation).</p>"},{"location":"installation/#3-run-the-development-server","title":"3. Run the Development Server","text":"<p>With the code cloned and dependencies installed, you can now start the local development server. This server compiles the code, serves the application files, and often provides features like hot-reloading for a smooth development experience.</p> <p>Execute the following command in your terminal from the project directory:</p> <pre><code>npm run dev\n</code></pre> <ul> <li><code>npm run dev</code>: This command executes a predefined script named <code>dev</code> within the <code>package.json</code> file. Typically, this script is configured to start a local development server, often using a framework or build tool like Next.js, React, Vue, etc.</li> </ul> <p>Running the development server makes the application accessible through your web browser on your local machine. This is the environment where you can see the project in action, interact with its features, and observe how changes to the code affect the live application.</p>"},{"location":"installation/#4-open-in-your-browser","title":"4. Open in Your Browser","text":"<p>Finally, access the running application by opening your web browser and navigating to the local server address.</p> <p>Open your preferred web browser and go to:</p> <pre><code>http://localhost:3000\n</code></pre> <p>(Note: The port number <code>3000</code> is common, but it might vary depending on the project's configuration. If it's different, the terminal output from <code>npm run dev</code> will usually indicate the correct address.)</p> <p>This will load the project's user interface in your browser, allowing you to interact with it just as a user would.</p>"},{"location":"installation/#benefits-of-local-hosting-and-exploration","title":"Benefits of Local Hosting and Exploration","text":"<p>Setting up and running the project locally offers significant advantages beyond simply using the application:</p> <ul> <li>Code Exploration: You have full access to the entire codebase. You can open files, read through the logic, understand how different features are implemented, and trace the flow of data. This is invaluable for learning and comprehending the project's architecture.</li> <li>Safe Experimentation: The local environment is your sandbox. You can make changes to the code, test new ideas, and break things without affecting anyone else or the live project. This freedom is crucial for learning and development.</li> <li>Debugging and Troubleshooting: When running locally, you can use browser developer tools and code debuggers to step through the code, inspect variables, and identify the root cause of issues.</li> <li>Contribution Pathway: For those interested in contributing, a local setup is the first step. It allows you to build new features, fix bugs, and propose improvements. You can test your changes thoroughly in your local environment before submitting them back to the project.</li> <li>Offline Access: Once cloned and dependencies installed, you can work on the project offline, which is convenient for development in various environments.</li> </ul> <p>By following these steps and exploring the locally hosted project, you gain a deeper understanding of its workings and empower yourself to not just use it, but potentially enhance it for the benefit of the community.</p>"},{"location":"usage/","title":"Usefulness and Usage of DAA for Kids","text":"<p>The DAA for Kids project is more than just a collection of algorithm visualizations; it is a comprehensive tool designed to fundamentally change how Design and Analysis of Algorithms (DAA) is learned, understood, and applied. By transforming abstract concepts into tangible, interactive experiences, the project unlocks numerous possibilities for students, educators, and anyone interested in the world of algorithms.</p>"},{"location":"usage/#empowering-student-learning","title":"Empowering Student Learning","text":"<p>Traditional methods of learning algorithms often rely heavily on static diagrams and theoretical explanations, which can make grasping complex processes challenging. The DAA for Kids visualizer directly addresses this by providing a dynamic learning environment:</p> <ul> <li>Intuitive Understanding: Witnessing an algorithm execute step-by-step on a visual grid or data structure provides an unparalleled level of intuition. Instead of just memorizing formulas or rules, students can see why an algorithm behaves the way it does, how it makes decisions, and how data is transformed at each stage.</li> <li>Active Engagement: The interactive nature of the visualizers encourages active learning. Students can manipulate inputs, set parameters, and observe the direct impact on the algorithm's execution. This hands-on approach fosters deeper engagement and makes learning more memorable than passive reading or watching.</li> <li>Demystifying Complexity: Algorithms like A* search, Dynamic Programming for Knapsack, or Huffman encoding can seem daunting at first glance. The visualizer breaks these down into manageable, observable steps, making complex logic more accessible and less intimidating.</li> <li>Identifying and Correcting Misconceptions: When an algorithm doesn't produce the expected result, students can trace its execution step-by-step in the visualizer to pinpoint exactly where their understanding or the algorithm's logic diverges. This is a powerful debugging tool for learning.</li> </ul>"},{"location":"usage/#a-powerful-revision-tool","title":"A Powerful Revision Tool","text":"<p>Beyond initial learning, the DAA for Kids project serves as an invaluable resource for revising and solidifying algorithmic knowledge:</p> <ul> <li>Quick Refreshers: Before exams, interviews, or tackling new problems, students can quickly run through visualizations to refresh their memory on how a specific algorithm works, its key steps, and its behavior.</li> <li>Comparing Algorithms: The visualizer allows for side-by-side comparison of different algorithms solving the same problem (where applicable), such as comparing Greedy vs. Dynamic Programming for Knapsack, or different pathfinding algorithms. Seeing their approaches and outcomes simultaneously highlights their strengths, weaknesses, and suitability for different scenarios.</li> <li>Reinforcing Concepts: Repeatedly visualizing algorithms helps reinforce the underlying theoretical concepts, such as the greedy choice property, optimal substructure, or the principles of graph traversal.</li> <li>Practical Application Context: Seeing algorithms applied to visual problems (like pathfinding on a grid or packing items in a knapsack) helps students connect the theoretical algorithm to practical scenarios, aiding in recall and application.</li> </ul>"},{"location":"usage/#utility-for-educators","title":"Utility for Educators","text":"<p>Educators can integrate the DAA for Kids visualizer into their teaching methodologies to create more engaging and effective lessons:</p> <ul> <li>Live Demonstrations: The visualizer is an excellent tool for live demonstrations in lectures or tutorials. Instead of drawing static diagrams on a whiteboard, educators can show algorithms running in real-time, making explanations more dynamic and easier for students to follow.</li> <li>Interactive Assignments: Educators can design assignments that require students to use the visualizer, explore different inputs, predict outcomes, or explain the algorithm's behavior based on the visualization.</li> <li>Supplementing Lectures: The visualizer can serve as a supplementary resource that students can access outside of class to review concepts covered in lectures or explore algorithms at their own pace.</li> <li>Flipping the Classroom: Educators could assign students to interact with a visualization before a lecture, allowing class time to be used for deeper discussion, problem-solving, and addressing specific questions.</li> </ul>"},{"location":"usage/#broader-applications-and-community-engagement","title":"Broader Applications and Community Engagement","text":"<p>The usefulness of the DAA for Kids project extends beyond formal educational settings:</p> <ul> <li>Algorithm Enthusiasts: Anyone with an interest in algorithms, regardless of their background, can use the visualizer to explore how fundamental computer science concepts work.</li> <li>Interview Preparation: Visualizing algorithms is a highly effective way to prepare for technical interviews that often involve algorithmic problem-solving.</li> <li>Contribution and Learning: As an open-source project, DAA for Kids also serves as a platform for learning about software development, contributing to a community project, and gaining experience in building educational tools.</li> </ul> <p>In conclusion, the DAA for Kids project leverages the power of visualization and interactivity to transform the learning experience of algorithms. By providing a clear, engaging, and hands-on approach, it empowers students to build a strong foundation in DAA, serves as a dynamic tool for revision, supports educators in delivering impactful lessons, and invites enthusiasts to explore the beauty of algorithmic thinking. We believe this project is a valuable asset for anyone looking to understand and master the essential concepts of Design and Analysis of Algorithms.</p>"},{"location":"components/huffman/","title":"Huffman Encoding Visualizer","text":"<p>Welcome to the Huffman Encoding Visualizer module, a tool designed to demystify the process of data compression using the Huffman coding algorithm. Understanding how data can be efficiently represented is a key concept in computer science, and this visualizer makes the principles of Huffman encoding clear and interactive.</p>"},{"location":"components/huffman/#understanding-huffman-encoding","title":"Understanding Huffman Encoding","text":"<p>Huffman Encoding is a widely used lossless data compression algorithm. It works by assigning variable-length codes to input characters, where the length of each code is inversely proportional to the frequency of the character. More frequent characters get shorter codes, while less frequent characters get longer codes. This results in a shorter average code length, leading to compression of the overall data.</p> <p>The core idea is to build a binary tree (the Huffman Tree) based on the frequencies of characters in the input data. The path from the root to each character leaf node represents its unique binary code.</p>"},{"location":"components/huffman/#exploring-the-visualizer","title":"Exploring the Visualizer","text":"<p>The Huffman Encoding Visualizer allows you to input text and see the entire encoding and decoding process unfold across different tabs.</p>"},{"location":"components/huffman/#visualization-tab","title":"Visualization Tab","text":"<p>The Visualization tab is where you can see the fundamental components of the Huffman encoding process:</p> <ul> <li>Huffman Tree: Witness the construction of the Huffman tree based on the character frequencies of your input text. The tree visually represents how character codes are derived.</li> <li>Character Frequencies: View a table listing each unique character in your input text and its corresponding frequency count. This is the basis for building the Huffman tree.</li> <li>Huffman Codes: See the generated variable-length binary code for each character. Observe how characters with higher frequencies have shorter codes.</li> </ul> <p>You can input your own text or select from Sample Texts to quickly explore different scenarios and see how the tree and codes change. The visualizer also immediately shows the Original size (in bits), the Compressed size (in bits), and the Space saved as a percentage, demonstrating the effectiveness of the compression.</p>"},{"location":"components/huffman/#encoding-tab","title":"Encoding Tab","text":"<p>The Encoding tab focuses on the process of converting your original text into its compressed binary representation. This page details the step-by-step process of encoding the input string using the generated Huffman codes and displays the resulting Encoded String. You can see how the original characters are replaced by their shorter binary codes, leading to the reduction in data size.</p>"},{"location":"components/huffman/#decoding-tab","title":"Decoding Tab","text":"<p>The Decoding tab allows you to take an encoded binary string and convert it back to the original text using the Huffman tree. This page demonstrates how the algorithm traverses the tree based on the binary code to reconstruct the original characters. You can also enter strings to decode, allowing you to experiment with the decoding process directly.</p>"},{"location":"components/huffman/#algorithm-pseudocode","title":"Algorithm Pseudocode","text":"<p>Understand the computational steps involved in constructing the Huffman Tree and generating the codes.</p> Select an Algorithm Huffman Encoding <p>Select an algorithm from the dropdown above to see its pseudocode.</p> <pre><code>Huffman_Encoding(text):\n    // 1. Calculate character frequencies\n    create a frequency map of characters in the text\n\n    // 2. Create priority queue of nodes\n    create a min-priority queue PQ\n    for each character and its frequency:\n        create a leaf node with character and frequency\n        PQ.add(node, frequency)\n\n    // 3. Build the Huffman Tree\n    while size of PQ &gt; 1:\n        // Extract the two nodes with the smallest frequencies\n        left_child = PQ.extract_min()\n        right_child = PQ.extract_min()\n\n        // Create a new internal node with frequency equal to the sum of the two children\n        // The new node's children are the extracted nodes\n        new_frequency = left_child.frequency + right_child.frequency\n        internal_node = create a node with new_frequency, left_child, right_child\n        PQ.add(internal_node, new_frequency)\n\n    // The remaining node in the PQ is the root of the Huffman Tree\n    huffman_tree_root = PQ.extract_min()\n\n    // 4. Generate Huffman Codes\n    create a map to store character codes\n    traverse the Huffman tree from the root:\n        if current node is a leaf:\n            store the path from root to this leaf as the character's code\n        else:\n            traverse left child, appending '0' to current path\n            traverse right child, appending '1' to current path\n\n    // 5. Encode the original text\n    encoded_string = \"\"\n    for each character in the original text:\n        append the character's Huffman code to encoded_string\n\n    return encoded_string, huffman_tree_root, character_codes\n</code></pre>"},{"location":"components/knapsack/","title":"Knapsack Problem Visualizer","text":"<p>Welcome to the Knapsack Problem Visualizer module, where you can explore the classic 0/1 Knapsack Problem through interactive visualizations. This module is designed to make understanding optimization problems and the power of dynamic programming both accessible and engaging.</p>"},{"location":"components/knapsack/#understanding-the-knapsack-problem","title":"Understanding the Knapsack Problem","text":"<p>The 0/1 Knapsack Problem is a fundamental problem in combinatorial optimization. Imagine you have a knapsack with a maximum weight capacity and a set of items, each with a specific weight and value. The problem is to determine which items to include in the knapsack such that the total weight does not exceed the capacity, and the total value is maximized. The \"0/1\" signifies that you can either take an item entirely (1) or not take it at all (0) \u2013 you cannot take a fraction of an item.</p> <p>Our visualizer helps you grasp the core concepts and different approaches to solving this problem.</p>"},{"location":"components/knapsack/#problem-setup","title":"Problem Setup","text":"<p>The journey begins on the Problem Setup page. Here, you define the parameters of your specific Knapsack problem:</p> <ul> <li>Bag Constraints: Set the maximum weight capacity your knapsack can hold. You can also specify an empty bag weight if relevant to your scenario.</li> <li>Add New Item: Define the items available to be potentially placed in the knapsack. For each item, you specify its name, weight, and monetary worth. You have the flexibility to add individual items or generate sets of items with varying characteristics (heavy, light, or mixed).</li> </ul> <p>This interactive setup allows you to create custom problem instances to test different scenarios and see how algorithms perform.</p>"},{"location":"components/knapsack/#solving-the-problem","title":"Solving the Problem","text":"<p>Once your problem is defined, you move to the Solve Problem section. Here, you choose the algorithm you want to use to find the optimal solution. While the visualizer may offer multiple approaches, the Dynamic Programming method is a central focus.</p> <p>The dynamic programming approach to the Knapsack Problem is particularly insightful. It builds a solution iteratively by considering smaller subproblems. The visualizer beautifully showcases this process by constructing the Dynamic Programming Table. This table systematically records the maximum value that can be obtained for different capacities and subsets of items. The visualizer allows you to manually traverse the steps of filling this table, providing a clear, step-by-step understanding of how the optimal solution is derived from the solutions to subproblems. This interactive exploration of the DP table is key to demystifying this powerful technique.</p>"},{"location":"components/knapsack/#viewing-results-and-comparison","title":"Viewing Results and Comparison","text":"<p>The View Results page presents the outcome of the chosen algorithm. You can see which items were selected for the knapsack, the total weight, and the total value achieved.</p> <p>A valuable feature of this module is the ability to Compare Both Algorithms (typically Dynamic Programming and the Greedy approach). The visualizer will run both algorithms on your defined problem instance and present their respective results side-by-side.</p> <p>Furthermore, an integrated AI Assistant is available throughout the module. On the comparison page, the AI Assistant provides insights into the performance of each algorithm for your specific problem instance, often highlighting why one might have performed better than the other, especially in cases where the Greedy approach fails to find the globally optimal solution that Dynamic Programming guarantees. This feature adds an extra layer of guidance and explanation to enhance your learning.</p>"},{"location":"components/knapsack/#algorithm-pseudocode","title":"Algorithm Pseudocode","text":"<p>Explore the fundamental logic behind the Greedy and Dynamic Programming approaches to the Knapsack Problem. Select an algorithm from the dropdown below to view its pseudocode.</p> Select an Algorithm Greedy Approach Dynamic Programming (0/1 Knapsack) <p>Select an algorithm from the dropdown above to see its pseudocode.</p> <pre><code>Greedy_Knapsack(items, capacity):\n    // items is a list of (value, weight) tuples\n    // capacity is the maximum weight the knapsack can hold\n\n    sort items by value-to-weight ratio in descending order\n\n    current_weight = 0\n    total_value = 0\n    knapsack_items = []\n\n    for each item (value, weight) in sorted items:\n        if current_weight + weight &lt;= capacity:\n            knapsack_items.add(item)\n            current_weight = current_weight + weight\n            total_value = total_value + value\n        // In 0/1 Knapsack, we cannot take a fraction, so we skip if it doesn't fit\n\n    return total_value, knapsack_items\n</code></pre> <pre><code>Dynamic_Programming_Knapsack(items, capacity):\n    // items is a list of (value, weight) tuples\n    // capacity is the maximum weight the knapsack can hold\n    // n is the number of items\n\n    n = number of items\n    create a DP table K of size (n+1) x (capacity+1)\n\n    // Build the DP table K[][]\n    for i from 0 to n:\n        for w from 0 to capacity:\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            else if items[i-1].weight &lt;= w:\n                // Max of including item i or excluding item i\n                K[i][w] = max(items[i-1].value + K[i-1][w - items[i-1].weight], K[i-1][w])\n            else:\n                // Item i cannot be included\n                K[i][w] = K[i-1][w]\n\n    // The maximum value is in K[n][capacity]\n    max_value = K[n][capacity]\n\n    // Reconstruct the items included (optional, but useful)\n    included_items = []\n    w = capacity\n    for i from n down to 1:\n        if max_value &lt;= 0:\n            break // Knapsack is full or no more value to add\n\n        // If the current value is NOT the same as the value excluding item i,\n        // then item i must have been included.\n        if max_value != K[i-1][w]:\n            included_items.add(items[i-1])\n            max_value = max_value - items[i-1].value\n            w = w - items[i-1].weight\n\n    return K[n][capacity], included_items\n</code></pre> <p>By utilizing the Knapsack Problem Visualizer, you can gain a deep, intuitive understanding of this classic optimization challenge, appreciate the elegance of dynamic programming, and see the practical differences between different algorithmic strategies.</p>"},{"location":"components/lcs/","title":"Longest Common Subsequence (LCS) Visualizer","text":"<p>Welcome to the Longest Common Subsequence (LCS) Visualizer module. This tool provides an interactive way to understand a fundamental problem in computer science and bioinformatics: finding the longest subsequence common to two sequences. While the concept might sound simple, the efficient solution often involves dynamic programming, which this visualizer helps illuminate.</p>"},{"location":"components/lcs/#understanding-the-longest-common-subsequence","title":"Understanding the Longest Common Subsequence","text":"<p>A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, \"ACE\" is a subsequence of \"ABCDE\". The Longest Common Subsequence (LCS) of two sequences is the longest subsequence that is present in both sequences. Unlike substrings, the common characters in an LCS do not need to be consecutive in the original sequences.</p> <p>The LCS problem has numerous applications, such as in file comparison utilities (like <code>diff</code>), bioinformatics for comparing DNA or protein sequences, and data compression.</p>"},{"location":"components/lcs/#exploring-the-visualizer","title":"Exploring the Visualizer","text":"<p>The LCS Visualizer is designed to make the dynamic programming approach to solving the 0/1 Knapsack Problem transparent and interactive. The main interface, as seen in the Visualization tab, centers around the DP Table Visualization.</p> <ul> <li>DP Table Visualization: This is the core of the visualizer. It displays the dynamic programming table used to compute the length of the LCS and reconstruct the subsequence itself. Each cell in the table represents the length of the LCS for prefixes of the two input strings.</li> <li>Interactive Steps: The visualizer allows you to manually traverse the steps involved in filling the DP table. You can see how each cell's value is calculated based on the values of previous cells and whether the corresponding characters in the input strings match. This step-by-step process is crucial for understanding the dynamic programming recurrence relation.</li> <li>Traceback: Once the DP table is filled, the visualizer can often show the traceback path through the table that reveals the actual Longest Common Subsequence.</li> </ul> <p>Beyond the main visualization, the page features additional tabs to deepen your understanding:</p> <ul> <li>Algorithm Tab: This section provides a clear and intuitive explanation of the LCS algorithm through text, breaking down the logic and concepts without relying solely on the visualization.</li> <li>Applications Tab: This tab details the various use cases and real-world applications of the Longest Common Subsequence problem across different fields, highlighting its practical importance.</li> </ul>"},{"location":"components/lcs/#algorithm-pseudocode","title":"Algorithm Pseudocode","text":"<p>Understand the computational steps behind the Dynamic Programming approach to the LCS problem by reviewing its pseudocode.</p> Select an Algorithm Dynamic Programming (LCS) <p>Select an algorithm from the dropdown above to see its pseudocode.</p> <pre><code>LCS_Length(string_A, string_B):\n    m = length of string_A\n    n = length of string_B\n\n    // Create a DP table dp of size (m+1) x (n+1)\n    // dp[i][j] will store the length of LCS of string_A[0..i-1] and string_B[0..j-1]\n    create a table dp of size (m+1) x (n+1)\n\n    // Fill dp table in bottom-up manner\n    for i from 0 to m:\n        for j from 0 to n:\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            else if string_A[i-1] == string_B[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    // dp[m][n] contains the length of the LCS for string_A and string_B\n    lcs_length = dp[m][n]\n\n    // Optional: Reconstruct the LCS string\n    lcs_string = \"\"\n    i = m\n    j = n\n    while i &gt; 0 and j &gt; 0:\n        if string_A[i-1] == string_B[j-1]:\n            lcs_string = string_A[i-1] + lcs_string // Prepend character\n            i = i - 1\n            j = j - 1\n        elif dp[i-1][j] &gt; dp[i][j-1]:\n            i = i - 1\n        else:\n            j = j - 1\n\n    return lcs_length, lcs_string\n</code></pre>"},{"location":"components/pathfinding/","title":"Pathfinding Algorithms Visualizer","text":"<p>Welcome to the Pathfinding Algorithms Visualizer module, a core component of the DAA for Kids project. This interactive tool is designed to illuminate the fascinating world of algorithms that find the shortest or optimal path between two points in a graph or grid. Understanding pathfinding is fundamental to many areas of computer science, from game development and robotics to network routing and logistics.</p>"},{"location":"components/pathfinding/#what-is-pathfinding","title":"What is Pathfinding?","text":"<p>At its heart, pathfinding is about navigating from a starting point to a destination, often avoiding obstacles and sometimes considering the \"cost\" of traversing different paths. Our visualizer brings these abstract concepts to life on a grid, allowing you to see exactly how various algorithms explore possible routes and determine the most efficient path.</p>"},{"location":"components/pathfinding/#using-the-visualizer","title":"Using the Visualizer","text":"<p>The visualizer provides a dynamic grid environment where you can:</p> <ul> <li> <p>Define the Environment: Place start and end nodes, draw walls to represent impassable obstacles, and add weights to cells to simulate varying traversal costs.</p> </li> <li> <p>Select an Algorithm: Choose from a diverse set of pathfinding algorithms.</p> </li> <li> <p>Control Execution: Start, pause, resume, and adjust the speed of the visualization to observe the algorithm's step-by-step process.</p> </li> <li> <p>Reset and Generate: Clear the grid or generate random maps to test algorithms under different conditions.</p> </li> </ul> <p>As the algorithm runs, you'll see nodes being visited, the path being constructed (if found), and understand the search pattern unique to each algorithm.</p>"},{"location":"components/pathfinding/#algorithms-explored","title":"Algorithms Explored","text":"<p>This visualizer offers a comprehensive look at a variety of pathfinding algorithms, categorized by their approach and suitability for different types of graphs (weighted vs. unweighted). Each algorithm brings a unique strategy to the problem of finding a path.</p>"},{"location":"components/pathfinding/#unweighted-graph-algorithms","title":"Unweighted Graph Algorithms","text":"<p>These algorithms are typically used on graphs where the cost of moving between any two connected nodes is the same (or assumed to be 1). They focus on finding the path with the fewest steps.</p> <ul> <li> <p>Breadth-First Search (BFS): Explores the graph level by level, guaranteeing the shortest path in terms of the number of edges.</p> </li> <li> <p>Depth-First Search (DFS): Explores as far down one branch as possible before backtracking, often used for traversal but not guaranteed to find the shortest path.</p> </li> </ul>"},{"location":"components/pathfinding/#weighted-graph-algorithms","title":"Weighted Graph Algorithms","text":"<p>When edges or nodes have different associated costs (weights), these algorithms are necessary to find the path with the minimum total cost.</p> <ul> <li> <p>Dijkstra\u2019s Algorithm: Finds the shortest paths from a single source node to all other nodes in a graph with non-negative edge weights.</p> </li> <li> <p>A* Search Algorithm: An extension of Dijkstra's that uses a heuristic function to guide its search, making it more efficient in many cases, especially for finding a path to a specific destination.</p> </li> <li> <p>Greedy Best-First Search: Uses a heuristic to prioritize exploration towards the target, but does not guarantee the shortest path.</p> </li> <li> <p>Bellman-Ford Algorithm: Can find the shortest paths from a single source node even in graphs with negative edge weights (though it detects negative cycles).</p> </li> <li> <p>Floyd-Warshall Algorithm: Finds the shortest paths between all pairs of nodes in a weighted graph.</p> </li> </ul>"},{"location":"components/pathfinding/#advanced-and-specialized-algorithms","title":"Advanced and Specialized Algorithms","text":"<p>This category includes algorithms designed for specific scenarios or offering alternative approaches to pathfinding.</p> <ul> <li> <p>Bidirectional Search: Runs two searches simultaneously, one from the start and one from the end, meeting in the middle. Can be faster than a single-direction search.</p> </li> <li> <p>Jump Point Search: An optimization for grid-based pathfinding that \"jumps\" over large areas, significantly speeding up search on uniform cost grids.</p> </li> </ul>"},{"location":"components/pathfinding/#algorithm-pseudocode","title":"Algorithm Pseudocode","text":"<p>Explore the fundamental logic behind each pathfinding algorithm. Select an algorithm from the dropdown below to view its pseudocode.</p> Select an Algorithm Breadth-First Search (BFS) Dijkstra\u2019s Algorithm A* Search Algorithm Greedy Best-First Search Bellman-Ford Algorithm Floyd-Warshall Algorithm {/* &lt;-- Check this value */}         Bidirectional Search Jump Point Search <p>Select an algorithm from the dropdown above to see its pseudocode.</p> <pre><code>BFS(graph, start_node, end_node):\n    create a queue Q\n    add start_node to Q\n    mark start_node as visited\n    create a map parent to store parent of each node\n\n    while Q is not empty:\n        current_node = Q.dequeue()\n\n        if current_node is end_node:\n            return reconstruct_path(parent, start_node, end_node)\n\n        for each neighbor of current_node:\n            if neighbor is not visited:\n                mark neighbor as visited\n                set parent[neighbor] = current_node\n                Q.enqueue(neighbor)\n\n    return \"No path found\"\n\nreconstruct_path(parent, start_node, end_node):\n    path = []\n    current = end_node\n    while current is not null:\n        path.add(current)\n        current = parent[current]\n    reverse path\n    return path\n</code></pre> <pre><code>Dijkstra(graph, start_node, end_node):\n    create a priority queue PQ\n    create a map distance, initialize all to infinity, distance[start_node] = 0\n    create a map parent to store parent of each node\n\n    PQ.add(start_node, 0) # node, priority\n\n    while PQ is not empty:\n        current_node = PQ.extract_min()\n\n        if current_node is end_node:\n            return reconstruct_path(parent, start_node, end_node)\n\n        for each neighbor of current_node:\n            edge_weight = weight(current_node, neighbor)\n            new_distance = distance[current_node] + edge_weight\n\n            if new_distance &lt; distance[neighbor]:\n                distance[neighbor] = new_distance\n                parent[neighbor] = current_node\n                if neighbor is in PQ:\n                    PQ.decrease_priority(neighbor, new_distance)\n                else:\n                    PQ.add(neighbor, new_distance)\n\n    return \"No path found\"\n\nreconstruct_path(parent, start_node, end_node):\n    path = []\n    current = end_node\n    while current is not null:\n        path.add(current)\n        current = parent[current]\n    reverse path\n    return path\n</code></pre> <pre><code>A_star(graph, start_node, end_node):\n    create a priority queue open_set\n    create a map came_from to store parent of each node\n    create a map g_score, initialize all to infinity, g_score[start_node] = 0\n    create a map f_score, initialize all to infinity, f_score[start_node] = heuristic(start_node, end_node)\n\n    open_set.add(start_node, f_score[start_node]) # node, priority\n\n    while open_set is not empty:\n        current_node = open_set.extract_min()\n\n        if current_node is end_node:\n            return reconstruct_path(came_from, start_node, end_node)\n\n        for each neighbor of current_node:\n            tentative_g_score = g_score[current_node] + distance(current_node, neighbor)\n\n            if tentative_g_score &lt; g_score[neighbor]:\n                came_from[neighbor] = current_node\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end_node)\n                if neighbor not in open_set:\n                    open_set.add(neighbor, f_score[neighbor])\n\n    return \"No path found\"\n\nheuristic(node_a, node_b):\n    // Implement a suitable heuristic function (e.g., Manhattan distance, Euclidean distance)\n    return estimated_distance_between(node_a, node_b)\n\nreconstruct_path(came_from, start_node, end_node):\n    path = []\n    current = end_node\n    while current is not null:\n        path.add(current)\n        current = came_from[current]\n    reverse path\n    return path\n</code></pre> <pre><code>Greedy_Best_First_Search(graph, start_node, end_node):\n    create a priority queue PQ\n    create a map came_from to store parent of each node\n    create a set visited\n\n    PQ.add(start_node, heuristic(start_node, end_node)) # node, priority based on heuristic\n\n    while PQ is not empty:\n        current_node = PQ.extract_min()\n\n        if current_node is end_node:\n            return reconstruct_path(came_from, start_node, end_node)\n\n        if current_node is in visited:\n            continue\n        mark current_node as visited\n\n        for each neighbor of current_node:\n            if neighbor not in visited:\n                came_from[neighbor] = current_node\n                PQ.add(neighbor, heuristic(neighbor, end_node))\n\n\n    return \"No path found\"\n\nheuristic(node_a, node_b):\n    // Implement a suitable heuristic function (e.g., Manhattan distance, Euclidean distance)\n    return estimated_distance_between(node_a, node_b)\n\nreconstruct_path(came_from, start_node, end_node):\n    path = []\n    current = end_node\n    while current is not null:\n        path.add(current)\n        current = came_from[current]\n    reverse path\n    return path\n</code></pre> <pre><code>Bellman_Ford(graph, start_node):\n    create a map distance, initialize all to infinity, distance[start_node] = 0\n    create a map parent to store parent of each node\n\n    num_vertices = number of vertices in graph\n\n    // Relax edges |V| - 1 times\n    repeat num_vertices - 1 times:\n        for each edge (u, v) with weight w in graph:\n            if distance[u] + w &lt; distance[v]:\n                distance[v] = distance[u] + w\n                parent[v] = u\n\n    // Check for negative cycles\n    for each edge (u, v) with weight w in graph:\n        if distance[u] + w &lt; distance[v]:\n            return \"Graph contains a negative cycle\" // Cannot find shortest paths\n\n    return distance, parent // Returns shortest distances from start_node and parent pointers\n\n// Note: To find the path to a specific end_node, you would reconstruct it\n// using the parent map after the algorithm completes and confirms no negative cycles.\nreconstruct_path(parent, start_node, end_node):\n    path = []\n    current = end_node\n    // Add a check to prevent infinite loops in case of issues or unreachable nodes\n    visited_check = set()\n    while current is not null and current not in visited_check:\n        path.add(current)\n        visited_check.add(current)\n        current = parent[current]\n    // Check if start_node was reached (current is null if not)\n    if current is null and start_node not in path:\n         return \"Path could not be reconstructed\" # Or handle as an error\n    reverse path\n    return path\n</code></pre>  {/* &lt;-- Check this ID */}         ```python         Floyd_Warshall(graph):             num_vertices = number of vertices in graph             create a matrix dist of size num_vertices x num_vertices             create a matrix next_node of size num_vertices x num_vertices // To reconstruct paths              // Initialize dist matrix             for i from 0 to num_vertices - 1:                 for j from 0 to num_vertices - 1:                     if i == j:                         dist[i][j] = 0                     elif edge exists from i to j:                         dist[i][j] = weight(i, j)                         next_node[i][j] = j                     else:                         dist[i][j] = infinity                         next_node[i][j] = null              // Apply the algorithm             for k from 0 to num_vertices - 1: // Intermediate vertices                 for i from 0 to num_vertices - 1: // Start vertices                     for j from 0 to num_vertices - 1: // End vertices                         if dist[i][k] is not infinity and dist[k][j] is not infinity:                             if dist[i][k] + dist[k][j] &lt; dist[i][j]:                                 dist[i][j] = dist[i][k] + dist[k][j]                                 next_node[i][j] = next_node[i][k]          // dist matrix now contains shortest paths between all pairs         // next_node matrix can be used to reconstruct paths          return dist, next_node      reconstruct_path_floyd_warshall(start_node, end_node, next_node):          if next_node[start_node][end_node] is null:              return \"No path exists\" // Or handle as error           path = [start_node]          current = start_node          while current is not end_node:              current = next_node[current][end_node]              path.add(current)           return path         ```      <pre><code>Bidirectional_Search(graph, start_node, end_node):\n    create queue_forward and queue_backward\n    create visited_forward and visited_backward sets\n    create parent_forward and parent_backward maps\n\n    queue_forward.enqueue(start_node)\n    visited_forward.add(start_node)\n    parent_forward[start_node] = null\n\n    queue_backward.enqueue(end_node)\n    visited_backward.add(end_node)\n    parent_backward[end_node] = null\n\n    while queue_forward is not empty and queue_backward is not empty:\n        // Search from start\n        current_f = queue_forward.dequeue()\n        if current_f in visited_backward:\n            return reconstruct_bidirectional_path(parent_forward, parent_backward, current_f)\n\n        for each neighbor of current_f:\n            if neighbor not in visited_forward:\n                visited_forward.add(neighbor)\n                parent_forward[neighbor] = current_f\n                queue_forward.enqueue(neighbor)\n\n        // Search from end\n        current_b = queue_backward.dequeue()\n        if current_b in visited_forward:\n            return reconstruct_bidirectional_path(parent_forward, parent_backward, current_b)\n\n        for each neighbor of current_b:\n            if neighbor not in visited_backward:\n                visited_backward.add(neighbor)\n                parent_backward[neighbor] = current_b\n                queue_backward.enqueue(neighbor)\n\n    return \"No path found\" // Queues are empty and no intersection found\n\nreconstruct_bidirectional_path(parent_forward, parent_backward, meeting_node):\n    path = []\n    // Path from start to meeting_node\n    current = meeting_node\n    while current is not null:\n        path.add(current)\n        current = parent_forward[current]\n    reverse path\n\n    // Path from meeting_node to end_node\n    current = parent_backward[meeting_node] // Start from the node *before* the meeting node in backward search\n    while current is not null:\n        path.add(current)\n        current = parent_backward[current]\n\n    return path\n</code></pre> <pre><code>// Note: Jump Point Search is complex and typically implemented on a grid.\n// This pseudocode provides a high-level overview of the core idea.\n\nJPS(grid, start_node, end_node):\n    create open_set (priority queue)\n    create came_from map\n    create g_score map, initialize all to infinity, g_score[start_node] = 0\n    create f_score map, initialize all to infinity, f_score[start_node] = heuristic(start_node, end_node)\n\n    open_set.add(start_node, f_score[start_node])\n\n    while open_set is not empty:\n        current_node = open_set.extract_min()\n\n        if current_node is end_node:\n            return reconstruct_path(came_from, start_node, end_node)\n\n        // Find \"jump points\" from the current node\n        neighbors = find_jump_points(current_node, came_from[current_node], grid)\n\n        for each neighbor (jump_point):\n            tentative_g_score = g_score[current_node] + distance(current_node, jump_point)\n\n            if tentative_g_score &lt; g_score[jump_point]:\n                came_from[jump_point] = current_node\n                g_score[jump_point] = tentative_g_score\n                f_score[jump_point] = g_score[jump_point] + heuristic(jump_point, end_node)\n                if jump_point not in open_set:\n                    open_set.add(jump_point, f_score[jump_point])\n\n    return \"No path found\"\n\nfind_jump_points(current_node, parent_node, grid):\n    // This is the core complex part of JPS.\n    // It involves pruning redundant neighbors and recursively searching for forced neighbors\n    // and jump points in cardinal and diagonal directions.\n    // Returns a list of significant \"jump points\" reachable from current_node.\n    pass // Placeholder for complex logic\n\nheuristic(node_a, node_b):\n    // Implement a suitable heuristic function (e.g., Manhattan distance, Euclidean distance)\n    return estimated_distance_between(node_a, node_b)\n\nreconstruct_path(came_from, start_node, end_node):\n    path = []\n    current = end_node\n    while current is not null:\n        path.add(current)\n        current = came_from[current]\n    reverse path\n    return path\n</code></pre>"}]}